@using System.Text
@using BlazorDatasheet.Data
@using BlazorDatasheet.Edit.DefaultComponents
@using BlazorDatasheet.Interfaces
@using BlazorDatasheet.Render
@if (EditorManager.IsEditing)
{
    <div style="position:absolute; @GetEditorSizeStyling()">
        <DynamicComponent
            Type="ActiveEditorType"
            Parameters="@getEditorParameters()"
            @ref="ActiveEditorContainer"/>
    </div>
}

@code {

    /// <summary>
    /// The current list of actions that should be performed on the next render.
    /// </summary>
    private Queue<Action> QueuedActions { get; set; } = new Queue<Action>();

    private void NextTick(Action action)
    {
        QueuedActions.Enqueue(action);
    }

    /// The Dynamic component holding the Active Editor component
    internal DynamicComponent? ActiveEditorContainer { get; set; }

    private EditorManager _editorManager;

    [Parameter]
    public EditorManager EditorManager { get; set; }

    [Parameter]
    public CellLayoutProvider CellLayoutProvider { get; set; }

    [Parameter]
    public Sheet Sheet { get; set; }

    private Type? ActiveEditorType { get; set; }

    private Dictionary<string, object> getEditorParameters()
    {
        return new Dictionary<string, object>()
        {
            { "EditorManager", EditorManager },
        };
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        while (QueuedActions.Any())
        {
            var action = QueuedActions.Dequeue();
            action.Invoke();
        }
        return base.OnAfterRenderAsync(firstRender);
    }

    protected override void OnParametersSet()
    {
        if (EditorManager != _editorManager)
        {
    // Just before edit begins, find and set the correct editor type
            EditorManager.BeforeEditBegin += (sender, arg) =>
            {
                var cell = Sheet.GetCell(arg.Row, arg.Col);
    // Set the ActiveEditorType based on the cell's type - default to Text Editor
                if (this.Sheet.EditorTypes.ContainsKey(cell.Type))
                    ActiveEditorType = Sheet.EditorTypes[cell.Type];
                else
                    ActiveEditorType = typeof(TextEditorComponent);
                
                StateHasChanged();
            };

    // When edit begins, re-render to update the reference to dynamic component
    // and set the ICellEditor component as the instance of it
            EditorManager.EditBegin += (sender, args) =>
            {
    // Required to re-render after any edit component reference has changed
                StateHasChanged();
    // Because the ActiveEditor is null until the next re-render (unfortunately)
    // we need to queue the begin edit function until then
                NextTick(() =>
                {
                    var manager = (EditorManager)sender;
                    manager.ActiveEditorComponent = (ICellEditor)ActiveEditorContainer?.Instance;

                    manager
                        .ActiveEditorComponent?
                        .BeginEdit(args.Mode, Sheet.GetCell(args.Row, args.Col), args.EntryChar);


                    StateHasChanged();
                });
            };

    // When edit is cancelled, re-render which will remove overlay
            EditorManager.EditCancelled += (sender, args) =>
            {
                Console.WriteLine("Edit Cancelled");
                StateHasChanged();
            };

            EditorManager.EditAccepted += (sender, args) =>
            {
                Console.WriteLine("Edit acceptted");
                StateHasChanged();
            };
            _editorManager = EditorManager;
        }

        base.OnParametersSet();
    }

    /// <summary>
    /// Calculates the top/left/width/height styles of the editor container
    /// </summary>
    /// <returns></returns>
    private string GetEditorSizeStyling()
    {
        var strBuilder = new StringBuilder();

        var Position = EditorManager.CurrentEditPosition;
        var editorRegion = new Region(Position.Row, Position.Col);

        var left = CellLayoutProvider.ComputeLeftPosition(editorRegion);
        var top = CellLayoutProvider.ComputeTopPosition(editorRegion);
        var w = CellLayoutProvider.ComputeWidth(editorRegion);
        var h = CellLayoutProvider.ComputeHeight(editorRegion);

        strBuilder.Append($"left:{left}px;");
        strBuilder.Append($"top:{top}px;");
        strBuilder.Append($"width:{w}px;");
        strBuilder.Append($"height:{h}px;");
        strBuilder.Append($"box-shadow: 0px 0px 4px var(--shadow-overlay-color)");
        var style = strBuilder.ToString();
        return style;
    }


}