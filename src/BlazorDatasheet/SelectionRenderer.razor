@using System.Text
@using BlazorDatasheet.Render
@using Region = BlazorDatasheet.DataStructures.Geometry.Region
@using System.ComponentModel
@using BlazorDatasheet.Core.Data
@using BlazorDatasheet.DataStructures.Geometry
@using BlazorDatasheet.Events
@using BlazorDatasheet.Services
@using Microsoft.JSInterop
@inject IJSRuntime JS;
@implements IDisposable

<!-- Render the temp selection (currently selected region) -->
@if (Sheet != null && BoundedSelectingRegion != null && BoundedSelectingRegion?.Area > 0)
{
    <!-- We split into regions around the cell's start position, so that the cell's 
    start position shows the renderer underneath it -->
    var brokenRegions = BoundedSelectingRegion.Break(getRegion(Sheet.Selection.SelectingStartPosition));
    foreach (var region in brokenRegions)
    {
        <BoxOverlayRenderer
            BackgroundVisible="@true"
            BackgroundStyle="@bgStyle"
            BorderThickness="0"
            X="getLeft(region)"
            Y="getTop(region)"
            Width="getWidth(region)"
            Height="getHeight(region)"/>
    }
    <!-- now render the border around the whole thing -->
    <BoxOverlayRenderer
        BackgroundVisible="@false"
        BorderThickness="2"
        BackgroundStyle="@bgStyle"
        X="getLeft(BoundedSelectingRegion)"
        Y="getTop(BoundedSelectingRegion)"
        Width="getWidth(BoundedSelectingRegion)"
        Height="getHeight(BoundedSelectingRegion)"/>
}

<!-- render the selections that exist in the sheet -->
@if (Sheet?.Selection != null && !Sheet.Selection.IsEmpty())
{
    foreach (var region in Sheet.Selection.Regions)
    {
        var boundedRegion = region.GetIntersection(Sheet.Region);
        var isActiveRegion = region.Equals(Sheet.Selection.ActiveRegion);
        if (boundedRegion == null)
            continue;
        <!-- if it's the active region, render around the active position -->
        if (isActiveRegion)
        {
            var brokenRegions = boundedRegion
                .Break(getRegion(Sheet.Selection.ActiveCellPosition));
            foreach (var brokenRegion in brokenRegions)
            {
                <BoxOverlayRenderer
                    BackgroundStyle="@bgStyle"
                    BackgroundVisible="true"
                    BorderThickness="0"
                    X="getLeft(brokenRegion)"
                    Y="getTop(brokenRegion)"
                    Width="getWidth(brokenRegion)"
                    Height="getHeight(brokenRegion)"/>
            }
        }

        <!-- now render the border around the whole region. No fill on active region because we've filled it already -->
        <BoxOverlayRenderer
            BackgroundVisible="@(!isActiveRegion)"
            BorderThickness="@(isActiveRegion ? 2 : 0)"
            BackgroundStyle="@bgStyle"
            X="getLeft(boundedRegion)"
            Y="getTop(boundedRegion)"
            Width="getWidth(boundedRegion)"
            Height="getHeight(boundedRegion)"/>
    }
}

<!-- render dragger (bottom right corner) -->
<div id="auto-filler"
     @onpointerdown="DraggerMouseDown"
     style="@GetDraggerStyleString();cursor:crosshair;pointer-events: all;">
</div>

<!-- drag preview -->
@if (_isDragging && _dragPreviewRegion != null)
{
    <BoxOverlayRenderer
        BackgroundVisible="false"
        BorderThickness="1"
        X="getLeft(_dragPreviewRegion)"
        Y="getTop(_dragPreviewRegion)"
        Width="getWidth(_dragPreviewRegion)"
        Height="getHeight(_dragPreviewRegion)"/>
}

@code {

    [Parameter, EditorRequired]
    public CellLayoutProvider CellLayoutProvider { get; set; }

    private Sheet? _sheet;

    [Parameter, EditorRequired]
    public Sheet? Sheet { get; set; }

    [Parameter]
    public EventCallback<SelectionExpandedEventArgs> SelectionExpanded { get; set; }

    private bool _isDragging = false;
    private double _dragStartX;
    private double _dragStartY;

    private IRegion _dragPreviewRegion;

    private string bgStyle = "background:var(--selection-bg-color);";
    private IWindowEventService _windowEventService;

    private IRegion? BoundedSelectingRegion => Sheet?.Selection.SelectingRegion?.GetIntersection(Sheet?.Region);

    private double getLeft(IRegion region) => CellLayoutProvider.ComputeLeftPosition(region) + 1;
    private double getTop(IRegion region) => CellLayoutProvider.ComputeTopPosition(region) + 1;
    private double getWidth(IRegion region) => CellLayoutProvider.ComputeWidth(region) - 2;
    private double getHeight(IRegion region) => CellLayoutProvider.ComputeHeight(region) - 2;

    protected override void OnParametersSet()
    {
        if (_sheet != Sheet)
        {
            if (_sheet != null)
            {
                _sheet.Selection.SelectionChanged -= OnSelectionChanged;
                _sheet.Selection.SelectingChanged -= OnSelectingChanged;
            }
            _sheet = Sheet;

            if (_sheet == null) return;

            _sheet.Selection.SelectionChanged += OnSelectionChanged;
            _sheet.Selection.SelectingChanged += OnSelectingChanged;
        }
    }

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _windowEventService = new WindowEventService(JS);
            await _windowEventService.Init();
            _windowEventService.OnMouseUp += WindowEventServiceOnOnMouseUp;
            _windowEventService.OnMouseMove += WindowEventServiceOnOnMouseMove;
        }
    }

    // Returns the region that the position covers (may be > 1 because of merged cells)
    private IRegion getRegion(CellPosition position)
    {
        var merge = Sheet.Cells?.GetMerge(position.row, position.col);
        if (merge != null)
            return merge;
        else
            return new Region(position.row, position.col);
    }

    private string GetDraggerStyleString()
    {
        var region = Sheet.Selection.ActiveRegion ?? Sheet.Selection.SelectingRegion;
        if (region == null)
            return "display:none;";

        var x = CellLayoutProvider.ComputeLeftPosition(region.Right + 1);
        var y = CellLayoutProvider.ComputeTopPosition(region.Bottom + 1);
        var w = 6d;
        var h = 6d;
        var sb = new StringBuilder();
        sb.Append($"display:block;position:absolute;");
        sb.Append($"left:{x - w / 2}px;top:{y - w / 2}px;");
        sb.Append($"width:{w}px;height:{h}px;");
        sb.Append("background:var(--selection-border-color);");
        sb.Append("border:1px solid white;");
        return sb.ToString();
    }

    private void OnSelectionChanged(object? sender, IEnumerable<IRegion> regions)
    {
        StateHasChanged();
    }

    private void OnSelectingChanged(object? sender, IRegion region)
    {
        StateHasChanged();
    }

    private void DraggerMouseDown(PointerEventArgs obj)
    {
        if (Sheet?.Selection.ActiveRegion == null)
            return;

        _isDragging = true;
        _dragStartX = obj.ScreenX;
        _dragStartY = obj.ScreenY;
    }

    private async Task<bool> WindowEventServiceOnOnMouseMove(MouseEventArgs arg)
    {
        _dragPreviewRegion = null;
        if (!_isDragging || _sheet?.Selection.ActiveRegion == null)
            return false;

        var dx = (arg.ScreenX - _dragStartX);
        var dy = (arg.ScreenY - _dragStartY);

    // x y coord of cursor relative to sheet (0, 0)
        var posn = new Point2d(CellLayoutProvider.ComputeRightPosition(_sheet.Selection.ActiveRegion.Right) + dx,
            CellLayoutProvider.ComputeBottomPosition(_sheet.Selection.ActiveRegion.Bottom) + dy);

        var cell = new CellPosition(CellLayoutProvider.ComputeRow(posn.Y), CellLayoutProvider.ComputeColumn(posn.X));
    // x y coords of top-left of cell
        var cellPosition = new Point2d(CellLayoutProvider.ComputeLeftPosition(cell.col), CellLayoutProvider.ComputeTopPosition(cell.row));
        var cellHalfWidth = CellLayoutProvider.ComputeWidth(cell.col, 1) / 2;
        var cellHalfHeight = CellLayoutProvider.ComputeHeight(cell.row, 1) / 2;
    // if the posn is the top or left of the cell then we need to decrease cellPosn because we are using the centre
    // of the cell to determine its position
        var rowCorrection = 0;
        var colCorrection = 0;

        if (cell.col != _sheet.Selection.ActiveRegion.Right)
        {
            if (posn.X < cellPosition.X + cellHalfWidth)
                colCorrection = -1;
            if (posn.Y < cellPosition.Y + cellHalfHeight)
                rowCorrection = -1;
        }

        var endCol = colCorrection + cell.col;
        var endRow = rowCorrection + cell.row;

        var axis = System.Math.Abs(dx) > Math.Abs(dy) ? Axis.Col : Axis.Row;

        if (axis == Axis.Row)
            endCol = _sheet.Selection.ActiveRegion.Right;
        else
            endRow = _sheet.Selection.ActiveRegion.Bottom;


        _dragPreviewRegion = new Region(_sheet.Selection.ActiveRegion.Top,
            endRow,
            _sheet.Selection.ActiveRegion.Left,
            endCol);

        this.StateHasChanged();
        return true;
    }

    public void Dispose()
    {
        _windowEventService?.Dispose();
    }


    private async Task<bool> WindowEventServiceOnOnMouseUp(MouseEventArgs arg)
    {
        if (_isDragging)
        {
            Console.WriteLine("ENDED");
            await SelectionExpanded.InvokeAsync(new SelectionExpandedEventArgs(_sheet.Selection.ActiveRegion.Clone(), _dragPreviewRegion.Clone()));
            _isDragging = false;
            _dragPreviewRegion = null;
            this.StateHasChanged();
        }
        return true;
    }

}