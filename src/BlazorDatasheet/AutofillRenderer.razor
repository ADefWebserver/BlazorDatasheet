@using System.Text
@using BlazorDatasheet.Core.Data
@using BlazorDatasheet.Core.Layout
@using BlazorDatasheet.DataStructures.Geometry
@using BlazorDatasheet.Events
@using BlazorDatasheet.Services
@using Microsoft.JSInterop
@implements IDisposable
@inject IJSRuntime JS;
@inject IWindowEventService WindowEventService

@if (!Sheet!.Editor.IsEditing)
{
    <!-- render dragger (bottom right corner) -->
    <div id="auto-filler"
         class="unselectable"
         @onpointerdown="DraggerMouseDown"
         @onpointerup="DraggerMouseUp"
         style="@GetDraggerStyleString();cursor:crosshair;pointer-events: all;">
    </div>
}


<!-- drag preview -->
@if (_isDragging && _dragPreviewRegion != null)
{
    <BoxOverlayRenderer
        BackgroundVisible="false"
        BorderThickness="1"
        X="GetLeft(_dragPreviewRegion)"
        Y="GetTop(_dragPreviewRegion)"
        Width="GetWidth(_dragPreviewRegion)"
        Height="GetHeight(_dragPreviewRegion)"/>
}

@code {
    [Parameter, EditorRequired] public Sheet? Sheet { get; set; }

    [Parameter, EditorRequired] public CellLayoutProvider CellLayoutProvider { get; set; } = null!;

    [Parameter, EditorRequired] public SheetPointerInputService? InputService { get; set; }


    [Parameter] public EventCallback<SelectionExpandedEventArgs> SelectionExpanded { get; set; }

    private bool _isDragging = false;

    // Document start position of the pointer
    private Point2d _dragStartDocumentPosition = new Point2d();
    private IRegion? _dragPreviewRegion;

    private double GetLeft(IRegion region) => CellLayoutProvider.ComputeLeftPosition(region);
    private double GetTop(IRegion region) => CellLayoutProvider.ComputeTopPosition(region);
    private double GetWidth(IRegion region) => CellLayoutProvider.ComputeWidth(region);
    private double GetHeight(IRegion region) => CellLayoutProvider.ComputeHeight(region);

    protected override void OnParametersSet()
    {
        if (Sheet != null)
        {
            Sheet.Selection.SelectingChanged -= SelectionOnSelectingChanged;
            Sheet.Selection.SelectingChanged += SelectionOnSelectingChanged;

            Sheet.Selection.SelectionChanged -= SelectionOnSelectionChanged;
            Sheet.Selection.SelectionChanged += SelectionOnSelectionChanged;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await WindowEventService.RegisterMouseEvent("mousemove", HandleWindowMouseMove);
            await WindowEventService.RegisterMouseEvent("mouseup", HandleWindowMouseUp);
        }
    }

    private async Task<bool> HandleWindowMouseUp(MouseEventArgs arg)
    {
        if (!_isDragging || _dragPreviewRegion == null)
            return false;

        await SelectionExpanded.InvokeAsync(new SelectionExpandedEventArgs(
            Sheet!.Selection.ActiveRegion!.Clone(),
            _dragPreviewRegion.Clone()));

        _isDragging = false;
        _dragPreviewRegion = null;

        return true;
    }

    private async Task<bool> HandleWindowMouseMove(MouseEventArgs e)
    {
        if (!_isDragging)
            return false;

        if (Sheet?.Selection.ActiveRegion == null)
            return false;

        var dx = e.PageX - _dragStartDocumentPosition.X;
        var dy = e.PageY - _dragStartDocumentPosition.Y;

        Console.WriteLine("HandleWindowMouseMove " + e.PageY);

        _dragPreviewRegion = CalculateDragPreviewRegion(dx, dy);
        this.StateHasChanged();

        return true;
    }

    private IRegion? CalculateDragPreviewRegion(double dx, double dy)
    {
        if (!_isDragging || Sheet.Selection.ActiveRegion == null)
            return null;

        if (dx == 0 || dy == 0)
            return null;

        var selRect = CellLayoutProvider.ComputeRect(Sheet.Selection.ActiveRegion);

        var sheetX = selRect.X + selRect.Width + dx;
        var sheetY = selRect.Y + selRect.Height + dy;

        var cellAtMouse = CellLayoutProvider.ComputeCell(sheetX, sheetY);

        var cellRect = CellLayoutProvider.ComputeRect(cellAtMouse);
        var dirMoved = GetDirection(dx, dy);
        var passesMidway = PassesMidway(cellRect, new Point2d(sheetX, sheetY), dirMoved);

        Console.WriteLine(cellAtMouse);
        Console.WriteLine(passesMidway);

        int colTo, rowTo;

        if (Math.Abs(dx) > Math.Abs(dy))
        {
            var dxDir = (int)(dx / Math.Abs(dx));
            colTo = cellAtMouse.col;
            rowTo = Sheet.Selection.ActiveRegion.Bottom;
            if (!passesMidway)
                colTo -= dxDir;
        }
        else
        {
            var dyDir = (int)(dy / Math.Abs(dy));
            rowTo = cellAtMouse.row;
            colTo = Sheet.Selection.ActiveRegion.Right;
            if (!passesMidway)
                rowTo -= dyDir;
        }

        return Sheet.Selection.ActiveRegion.GetBoundingRegion(new Region(rowTo, colTo));
    }

    private bool PassesMidway(Rect rect, Point2d pt, Direction direction)
    {
        switch (direction)
        {
            case Direction.None:
                return false;
            case Direction.Left:
                return pt.X < rect.X + rect.Width / 2;
            case Direction.Right:
                return pt.X > rect.X + rect.Width / 2;
            case Direction.Down:
                return pt.Y > rect.Y + rect.Height / 2;
            case Direction.Up:
                return pt.Y < rect.Y + rect.Height / 2;
        }

        return false;
    }

    private Direction GetDirection(double dx, double dy)
    {
        if (dx >= dy)
        {
            if (dx > 0)
                return Direction.Right;
            if (dx < 0)
                return Direction.Left;
            return Direction.None;
        }
        else
        {
            if (dy > 0)
                return Direction.Down;
            if (dy < 0)
                return Direction.Up;
        }

        return Direction.None;
    }


    private void SelectionOnSelectionChanged(object? sender, IEnumerable<IRegion> e)
    {
        StateHasChanged();
    }

    private void SelectionOnSelectingChanged(object? sender, IRegion? e)
    {
        StateHasChanged();
    }

    private async Task DraggerMouseDown(PointerEventArgs e)
    {
        if (Sheet?.Selection.ActiveRegion == null)
            return;

        _isDragging = true;

        _dragStartDocumentPosition = new Point2d(e.PageX, e.PageY);
    }

    private void DraggerMouseUp(PointerEventArgs obj)
    {
        // if the user mouses up on the dragger (which doesn't move)
        // then we should just cancel out of the drag
        _isDragging = false;
        _dragPreviewRegion = null;
        this.StateHasChanged();
    }

    private async void PointerMouseUp(object? sender, SheetPointerEventArgs? arg)
    {
        if (_isDragging && _dragPreviewRegion != null && Sheet?.Selection.ActiveRegion != null)
            await SelectionExpanded.InvokeAsync(new SelectionExpandedEventArgs(Sheet.Selection.ActiveRegion.Clone(), _dragPreviewRegion.Clone()));

        _isDragging = false;
        _dragPreviewRegion = null;
        this.StateHasChanged();
    }

    public void Dispose()
    {
    }

    private string GetDraggerStyleString()
    {
        if (Sheet == null)
            return string.Empty;

        var region = Sheet.Selection.ActiveRegion ?? Sheet.Selection.SelectingRegion;
        if (region == null)
            return "display:none;";

        var x = CellLayoutProvider.ComputeLeftPosition(region.Right + 1);
        var y = CellLayoutProvider.ComputeTopPosition(region.Bottom + 1);
        var w = 6d;
        var h = 6d;
        var sb = new StringBuilder();
        sb.Append($"display:block;position:absolute;");
        sb.Append($"left:{x - w / 2}px; top:{y - w / 2}px;");
        sb.Append($"width:{w}px;height:{h}px;");
        sb.Append("background:var(--selection-border-color);");
        sb.Append("border:1px solid var(--sheet-bg-color);");
        return sb.ToString();
    }

}